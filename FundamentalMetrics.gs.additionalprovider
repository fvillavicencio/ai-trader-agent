/**
 * Fundamental Metrics Module
 * Handles retrieval of fundamental metrics for stocks/ETFs including PEG ratios, 
 * Forward P/E Ratios, and other relevant metrics
 */

/**
 * Retrieves fundamental metrics for a list of stocks/ETFs
 * 
 * @param {Array} symbols - List of stock/ETF symbols to retrieve metrics for
 * @param {Array} mentionedStocks - List of stocks mentioned in market sentiment analysis
 * @return {Object} - Object containing fundamental metrics data
 */
function retrieveFundamentalMetrics(symbols = [], mentionedStocks = []) {
  try {
    Logger.log(`Retrieving fundamental metrics for ${symbols.length} stocks...`);
    
    // Clear cache and ensure it's cleared
    clearFundamentalMetricsCache();
    
    // Track execution time
    const startTime = new Date().getTime();
    
    // Combine user-provided symbols with default symbols
    const defaultSymbols = [ "SPY", "QQQ", "IWM", "DIA", "AAPL", "MSFT", "GOOGL", "AMZN", "META", "TSLA", "NVDA" ];
    
    // Add mentioned stocks to the symbols list if they're not already included
    const allMentionedStocks = mentionedStocks || [];
    Logger.log(`Mentioned stocks from market sentiment: ${allMentionedStocks.length > 0 ? allMentionedStocks.join(', ') : 'None'}`);
    
    // Create a set of all symbols to avoid duplicates
    const symbolsSet = new Set([...symbols, ...defaultSymbols, ...allMentionedStocks]);
    const allSymbols = Array.from(symbolsSet);
    
    Logger.log(`Retrieving fundamental metrics for ${allSymbols.length} symbols: ${allSymbols.join(', ')}`);
    
    // Initialize results array
    const results = [];
    const failedSymbols = [];
    
    // Track cache hits and misses
    let cacheHits = 0;
    let cacheMisses = 0;
    
    // Process each symbol
    for (const symbol of allSymbols) {
      Logger.log(`Retrieving fundamental metrics for ${symbol}...`);
      
      try {
        // Fetch fundamental metrics data for the symbol
        const metrics = fetchFundamentalMetricsData(symbol);
        
        // Check if data was from cache
        if (metrics && metrics.fromCache) {
          cacheHits++;
          Logger.log(`Retrieved ${symbol} metrics from cache`);
        } else {
          cacheMisses++;
        }
        
        // Verify we got valid data
        if (metrics && metrics.symbol && (metrics.price !== null || metrics.volume !== null)) {
          results.push(metrics);
          Logger.log(`Successfully retrieved metrics for ${symbol}`);
        } else {
          Logger.log(`No valid metrics data returned for ${symbol}`);
          failedSymbols.push(symbol);
        }
      } catch (error) {
        Logger.log(`Error retrieving metrics for ${symbol}: ${error}`);
        failedSymbols.push(symbol);
      }
    }
    
    // Calculate execution time
    const executionTime = (new Date().getTime() - startTime) / 1000;
    Logger.log(`Retrieved fundamental metrics for ${results.length} valid symbols in ${executionTime} seconds`);
    Logger.log(`Cache hits: ${cacheHits}, Cache misses: ${cacheMisses}`);
    Logger.log(`Failed symbols: ${failedSymbols.length > 0 ? failedSymbols.join(', ') : 'None'}`);

    // Return empty results if no valid data was found
    if (results.length === 0) {
      Logger.log('No valid results found for any symbols');
      return {
        metrics: [],
        failedSymbols: failedSymbols,
        executionTime: executionTime,
        cacheHits: cacheHits,
        cacheMisses: cacheMisses
      };
    }

    return {
      metrics: results,
      failedSymbols: failedSymbols,
      executionTime: executionTime,
      cacheHits: cacheHits,
      cacheMisses: cacheMisses
    };
  } catch (error) {
    Logger.log(`Error in retrieveFundamentalMetrics: ${error}`);
    return {
      metrics: [],
      failedSymbols: [],
      executionTime: 0,
      cacheHits: 0,
      cacheMisses: 0
    };
  }
}

/**
 * Fetches fundamental metrics data for a specific symbol
 * @param {String} symbol - The stock/ETF symbol
 * @return {Object} Fundamental metrics data
 */
function fetchFundamentalMetricsData(symbol) {
  try {
    Logger.log(`Fetching fundamental metrics for ${symbol} using cascading approach...`);
    
    // Check cache first (30-minute cache for fundamental metrics)
    const scriptCache = CacheService.getScriptCache();
    const cacheKey = `FUNDAMENTAL_METRICS_${symbol}`;
    
    // Get cached data
    const cachedData = scriptCache.get(cacheKey);
    if (cachedData) {
      try {
        const parsedData = JSON.parse(cachedData);
        const cacheTime = new Date(parsedData.lastUpdated);
        const currentTime = new Date();
        const cacheAgeMinutes = (currentTime - cacheTime) / (1000 * 60);
        
        if (cacheAgeMinutes < 30) {
          Logger.log(`Using cached fundamental metrics for ${symbol} (less than 30 minutes old)`);
          return { ...parsedData, fromCache: true };
        } else {
          Logger.log(`Cached fundamental metrics for ${symbol} is more than 30 minutes old`);
        }
      } catch (parseError) {
        Logger.log(`Error parsing cached data for ${symbol}: ${parseError}`);
        scriptCache.remove(cacheKey);
      }
    }
    
    // Track execution time
    const startTime = new Date().getTime();
    
    // Initialize metrics object
    let metrics = {
      symbol: symbol,
      price: null,
      priceChange: null,
      changesPercentage: null,
      volume: null,
      marketCap: null,
      industry: null,
      sector: null,
      company: null,
      pegRatio: null,
      forwardPE: null,
      priceToBook: null,
      priceToSales: null,
      debtToEquity: null,
      returnOnEquity: null,
      returnOnAssets: null,
      profitMargin: null,
      dividendYield: null,
      beta: null,
      expenseRatio: null,
      dataSource: [],
      fromCache: false
    };
    
    let sourcesUsed = [];
    let validMetricsCount = 0;
    
    // Try all data sources in order
    const dataSources = [
      { name: "Yahoo Finance API", func: fetchYahooFinanceData },
      { name: "Google Finance", func: fetchGoogleFinanceData },
      { name: "Tradier API", func: fetchTradierData },
      { name: "FMP API", func: fetchFMPData }
    ];

    for (const source of dataSources) {
      if (validMetricsCount < 5) {
        try {
          Logger.log(`Attempting to fetch data from ${source.name} for ${symbol}...`);
          const data = source.func(symbol);
          
          if (data && Object.keys(data).length > 0) {
            // Extract price data first
            metrics.price = data.price || null;
            metrics.priceChange = data.priceChange || null;
            metrics.changesPercentage = data.changesPercentage || null;
            metrics.volume = data.volume || null;
            metrics.marketCap = data.marketCap || null;
            metrics.company = data.company || null;
            
            // Then proceed with other metrics
            for (const key in data) {
              if (!metrics[key]) {
                metrics[key] = data[key];
                if (key !== 'price' && key !== 'volume') {
                  validMetricsCount++;
                }
              }
            }
            
            sourcesUsed.push(source.name);
          }
        } catch (error) {
          Logger.log(`Error fetching data from ${source.name} for ${symbol}: ${error}`);
        }
      }
    }
    
    // Finalize metrics object
    metrics.dataSource = sourcesUsed.join(", ");
    metrics.lastUpdated = new Date().toISOString();
    
    // Cache the data if we have valid metrics
    if (metrics.price !== null || metrics.volume !== null) {
      const cacheData = {
        ...metrics,
        fromCache: false,
        lastUpdated: metrics.lastUpdated
      };
      scriptCache.put(cacheKey, JSON.stringify(cacheData), 30 * 60); // 30-minute cache
      Logger.log(`Cached fundamental metrics for ${symbol}`);
    } else {
      Logger.log(`No valid metrics to cache for ${symbol}`);
    }

    // Get company name from the spreadsheet
    try {
      const spreadsheet = getSharedFinanceSpreadsheet();
      const sheet = spreadsheet.getSheetByName('Companies') || spreadsheet.insertSheet('Companies');
      
      // Find or create the company entry
      const data = sheet.getDataRange().getValues();
      let found = false;
      
      for (let i = 0; i < data.length; i++) {
        if (data[i][0] === symbol) {
          metrics.company = data[i][1];
          found = true;
          break;
        }
      }
      
      if (!found && metrics.company) {
        // Add new entry
        const nextRow = data.length + 1;
        sheet.getRange(nextRow, 1).setValue(symbol);
        sheet.getRange(nextRow, 2).setValue(metrics.company);
      }
    } catch (error) {
      Logger.log(`Error getting company name from spreadsheet: ${error}`);
    }

    const executionTime = (new Date().getTime() - startTime) / 1000;
    Logger.log(`Retrieved fundamental metrics for ${symbol} in ${executionTime} seconds`);
    Logger.log(`Sources used: ${metrics.dataSource}`);

    return metrics;
  } catch (error) {
    Logger.log(`Error in fetchFundamentalMetricsData: ${error}`);
    return {
      symbol: symbol,
      price: null,
      priceChange: null,
      changesPercentage: null,
      volume: null,
      dataSource: "Error",
      error: error.message
    };
  }
}

/**
 * Fetches data from FMP API for a specific symbol
 * @param {String} symbol - The stock/ETF symbol
 * @return {Object} FMP API data
 */
function fetchFMPData(symbol) {
  try {
    const FMP_API_KEY = PropertiesService.getScriptProperties().getProperty('FMP_API_KEY');
    if (!FMP_API_KEY) {
      throw new Error('FMP API key not found');
    }

    const url = `https://financialmodelingprep.com/api/v3/quote/${symbol}?apikey=${FMP_API_KEY}`;
    const response = UrlFetchApp.fetch(url);
    const data = JSON.parse(response.getContentText());
    
    if (data && data.length > 0) {
      const quote = data[0];
      return {
        price: quote.price,
        priceChange: quote.change,
        changesPercentage: quote.changesPercentage,
        volume: quote.volume,
        marketCap: quote.marketCap,
        company: quote.name,
        industry: quote.industry,
        sector: quote.sector
      };
    }
    
    return null;
  } catch (error) {
    Logger.log(`Error fetching FMP data for ${symbol}: ${error}`);
    return null;
  }
}

/**
 * Initializes script properties with necessary API keys
 */
function initializeScriptProperties() {
  const scriptProperties = PropertiesService.getScriptProperties();
  
  // Add FMP API key if not already present
  if (!scriptProperties.getProperty('FMP_API_KEY')) {
    scriptProperties.setProperty('FMP_API_KEY', 'YOUR_FMP_API_KEY');
  }
  
  // Add Yahoo Finance API key if not already present
  if (!scriptProperties.getProperty('YAHOO_FINANCE_API_KEY')) {
    scriptProperties.setProperty('YAHOO_FINANCE_API_KEY', 'YOUR_YAHOO_API_KEY');
  }
}

// Initialize script properties when the script is first run
initializeScriptProperties();

/**
 * Gets or creates a shared spreadsheet for Google Finance data
 * @return {Spreadsheet} The shared spreadsheet
 */
function getSharedFinanceSpreadsheet() {
  try {
    // Try to get the spreadsheet ID from script properties
    const scriptProperties = PropertiesService.getScriptProperties();
    const spreadsheetId = scriptProperties.getProperty('FINANCE_SPREADSHEET_ID');
    
    if (spreadsheetId) {
      try {
        // Try to open the existing spreadsheet
        return SpreadsheetApp.openById(spreadsheetId);
      } catch (e) {
        // If the spreadsheet doesn't exist anymore, create a new one
        Logger.log(`Existing finance spreadsheet not found, creating a new one: ${e.message}`);
      }
    }
    
    // Create a new spreadsheet
    const spreadsheet = SpreadsheetApp.create("AI Trading Agent - Finance Data");
    
    // Store the ID in script properties
    scriptProperties.setProperty('FINANCE_SPREADSHEET_ID', spreadsheet.getId());
    
    Logger.log(`Created new shared finance spreadsheet with ID: ${spreadsheet.getId()}`);
    
    return spreadsheet;
  } catch (error) {
    Logger.log(`Error getting or creating shared finance spreadsheet: ${error}`);
    throw error;
  }
}

/**
 * Initializes script properties with necessary API keys
 */
function initializeScriptProperties() {
  try {
    const scriptProperties = PropertiesService.getScriptProperties();
    
    // Initialize finance spreadsheet if not already set
    if (!scriptProperties.getProperty('FINANCE_SPREADSHEET_ID')) {
      const spreadsheet = getSharedFinanceSpreadsheet();
      scriptProperties.setProperty('FINANCE_SPREADSHEET_ID', spreadsheet.getId());
      Logger.log(`Initialized finance spreadsheet ID in script properties`);
    }
    
    // Initialize other necessary properties
    const requiredProperties = [
      'YAHOO_FINANCE_API_KEY',
      'TRADIER_API_KEY',
      'FMP_API_KEY'
    ];
    
    for (const prop of requiredProperties) {
      if (!scriptProperties.getProperty(prop)) {
        scriptProperties.setProperty(prop, '');
        Logger.log(`Initialized ${prop} in script properties`);
      }
    }
  } catch (error) {
    Logger.log(`Error initializing script properties: ${error}`);
    throw error;
  }
}

/**
 * Fetches data from Yahoo Finance for a specific symbol
 * @param {String} symbol - The stock/ETF symbol
 * @return {Object} Yahoo Finance data
 */
function fetchYahooFinanceData(symbol) {
  try {
    // Construct the Yahoo Finance URL for key statistics
    const url = `https://finance.yahoo.com/quote/${symbol}/key-statistics`;
    
    const options = {
      'method': 'GET',
      'headers': {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate, br',
        'DNT': '1',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1'
      },
      'muteHttpExceptions': true
    };
    
    // Fetch the page content
    const response = UrlFetchApp.fetch(url, options);
    const htmlContent = response.getContentText();
    
    // Extract metrics using regex
    const pegRatioMatch = htmlContent.match(/PEG Ratio[^<]*</td>\s*<td[^>]*>([\d.,]+|N\/A)<\/td>/is);
    const forwardPERatioMatch = htmlContent.match(/Forward P\/E[^<]*<\/td>\s*<td[^>]*>([\d.,]+|N\/A)<\/td>/is);
    const priceToBookMatch = htmlContent.match(/Price\/Book[^<]*<\/td>\s*<td[^>]*>([\d.,]+|N\/A)<\/td>/is);
    const priceToSalesMatch = htmlContent.match(/Price\/Sales[^<]*<\/td>\s*<td[^>]*>([\d.,]+|N\/A)<\/td>/is);
    const debtToEquityMatch = htmlContent.match(/Total\s+Debt\/Equity[^<]*<\/td>\s*<td[^>]*>([\d.,]+|N\/A)<\/td>/is);
    const returnOnEquityMatch = htmlContent.match(/Return\s+on\s+Equity[^<]*<\/td>\s*<td[^>]*>([\d.,]+%|N\/A)<\/td>/is);
    const returnOnAssetsMatch = htmlContent.match(/Return\s+on\s+Assets[^<]*<\/td>\s*<td[^>]*>([\d.,]+%|N\/A)<\/td>/is);
    const profitMarginMatch = htmlContent.match(/Profit\s+Margin[^<]*<\/td>\s*<td[^>]*>([\d.,]+%|N\/A)<\/td>/is);
    const betaMatch = htmlContent.match(/Beta\s*\([^)]*\)[^<]*<\/td>\s*<td[^>]*>([\d.,]+|N\/A)<\/td>/is);
    
    // Extract company information
    const companyMatch = htmlContent.match(/<h1[^>]*>([^<]+)<\/h1>/);
    const industryMatch = htmlContent.match(/Industry[^<]*<\/span>\s*<span[^>]*>([^<]+)<\/span>/);
    const sectorMatch = htmlContent.match(/Sector[^<]*<\/span>\s*<span[^>]*>([^<]+)<\/span>/);
    
    // Extract price and market cap
    const priceMatch = htmlContent.match(/<fin-streamer[^>]*data-field=\"regularMarketPrice\"[^>]*>([\d.,]+)<\/fin-streamer>/);
    const marketCapMatch = htmlContent.match(/Market\s+Cap[^<]*<\/td>\s*<td[^>]*>([\d.,]+\s*[A-Z]+|N\/A)<\/td>/is);
    
    // Extract volume
    const volumeMatch = htmlContent.match(/Volume[^<]*<\/td>\s*<td[^>]*>([\d.,]+|N\/A)<\/td>/is);
    
    // Extract dividend yield
    const dividendYieldMatch = htmlContent.match(/Dividend\s+Yield[^<]*<\/td>\s*<td[^>]*>([\d.,]+%|N\/A)<\/td>/is);
    
    // Create metrics object
    const metrics = {
      pegRatio: extractMetric(htmlContent, pegRatioMatch),
      forwardPE: extractMetric(htmlContent, forwardPERatioMatch),
      priceToBook: extractMetric(htmlContent, priceToBookMatch),
      priceToSales: extractMetric(htmlContent, priceToSalesMatch),
      debtToEquity: extractMetric(htmlContent, debtToEquityMatch),
      returnOnEquity: extractMetric(htmlContent, returnOnEquityMatch),
      returnOnAssets: extractMetric(htmlContent, returnOnAssetsMatch),
      profitMargin: extractMetric(htmlContent, profitMarginMatch),
      beta: extractMetric(htmlContent, betaMatch),
      dividendYield: extractMetric(htmlContent, dividendYieldMatch),
      
      // Add basic stock data
      company: companyMatch ? companyMatch[1].trim() : null,
      industry: industryMatch ? industryMatch[1].trim() : null,
      sector: sectorMatch ? sectorMatch[1].trim() : null,
      price: extractMetric(htmlContent, priceMatch),
      marketCap: marketCapMatch ? marketCapMatch[1].trim() : null,
      volume: extractMetric(htmlContent, volumeMatch)
    };
    
    return metrics;
  } catch (error) {
    Logger.log(`Error fetching Yahoo Finance data for ${symbol}: ${error}`);
    return null;
  }
}

/**
 * Fetches fundamental metrics from Google Finance
 * @param {string} symbol - The stock symbol
 * @return {Object} Metrics object
 */
function fetchGoogleFinanceData(symbol) {
  try {
    // Get the shared spreadsheet
    const spreadsheet = getSharedFinanceSpreadsheet();
    
    // Get the company data sheet
    const sheet = spreadsheet.getSheetByName('Company Data');
    if (!sheet) {
      Logger.log('Company Data sheet not found');
      return null;
    }
    
    // Find the row for this symbol
    const data = sheet.getDataRange().getValues();
    const headerRow = data[0];
    const symbolIndex = headerRow.indexOf('Symbol');
    const companyIndex = headerRow.indexOf('Company');
    const industryIndex = headerRow.indexOf('Industry');
    const sectorIndex = headerRow.indexOf('Sector');
    const priceIndex = headerRow.indexOf('Price');
    const marketCapIndex = headerRow.indexOf('Market Cap');
    const volumeIndex = headerRow.indexOf('Volume');
    
    if (symbolIndex === -1 || companyIndex === -1 || industryIndex === -1 || sectorIndex === -1) {
      Logger.log('Missing required columns in Company Data sheet');
      return null;
    }
    
    // Find the row for this symbol
    const symbolRow = data.find(row => row[symbolIndex] === symbol);
    if (!symbolRow) {
      Logger.log(`No data found for symbol ${symbol}`);
      return null;
    }
    
    // Create metrics object
    const metrics = {
      company: symbolRow[companyIndex],
      industry: symbolRow[industryIndex],
      sector: symbolRow[sectorIndex],
      price: parseFloat(symbolRow[priceIndex]),
      marketCap: symbolRow[marketCapIndex],
      volume: parseFloat(symbolRow[volumeIndex])
    };
    
    return metrics;
  } catch (error) {
    Logger.log(`Error fetching Google Finance data for ${symbol}: ${error}`);
    return null;
  }
}

/**
 * Extracts a metric from HTML content using regex
 * @param {String} htmlContent - The HTML content
 * @param {RegExp} regex - The regex pattern to extract the metric
 * @return {Number|null} The extracted metric or null if not found
 */
function extractMetric(htmlContent, regex) {
  try {
    const match = htmlContent.match(regex);
    
    if (match && match[1]) {
      // Check if the value is N/A
      if (match[1] === "N/A") {
        return null;
      }
      
      // Remove % sign if present and convert to number
      let value = match[1].replace('%', '');
      
      // Remove any commas in the number (e.g., 1,234.56 -> 1234.56)
      value = value.replace(/,/g, '');
      
      // Convert to number
      const numValue = parseFloat(value);
      
      // Check if the conversion was successful
      if (!isNaN(numValue)) {
        return numValue;
      }
    }
    
    return null;
  } catch (error) {
    Logger.log(`Error extracting metric: ${error}`);
    return null;
  }
}

/**
 * Fetches historical averages for a specific symbol
 * @param {String} symbol - The stock/ETF symbol
 * @return {Object} Historical averages
 */
function fetchHistoricalAverages(symbol) {
  try {
    // In a production environment, you would fetch historical data
    // For now, we'll simulate the data
    
    // For indices, use standard values
    if (["SPY", "QQQ", "IWM", "DIA"].includes(symbol)) {
      return {
        pegRatio: 1.5,
        forwardPE: 18.5,
        priceToBook: 3.2,
        priceToSales: 2.4
      };
    }
    
    // For Magnificent Seven, use higher values
    if (["AAPL", "MSFT", "GOOGL", "AMZN", "META", "TSLA", "NVDA"].includes(symbol)) {
      return {
        pegRatio: 2.1,
        forwardPE: 25.0,
        priceToBook: 8.5,
        priceToSales: 6.0
      };
    }
    
    // For other stocks, generate random values
    return {
      pegRatio: getRandomMetric(1.0, 2.5),
      forwardPE: getRandomMetric(15, 22),
      priceToBook: getRandomMetric(2, 5),
      priceToSales: getRandomMetric(1.5, 4)
    };
  } catch (error) {
    Logger.log(`Error fetching historical averages for ${symbol}: ${error}`);
    
    // Return placeholder data
    return {
      pegRatio: 0,
      forwardPE: 0,
      priceToBook: 0,
      priceToSales: 0
    };
  }
}

/**
 * Fetches sector averages for a specific symbol
 * @param {String} symbol - The stock/ETF symbol
 * @return {Object} Sector averages
 */
function fetchSectorAverages(symbol) {
  try {
    // In a production environment, you would determine the sector and fetch sector averages
    // For now, we'll use predefined sector averages based on the symbol
    
    // Define sector mappings (simplified)
    const sectorMappings = {
      "AAPL": "Technology",
      "MSFT": "Technology",
      "GOOGL": "Technology",
      "AMZN": "Consumer Cyclical",
      "META": "Technology",
      "TSLA": "Consumer Cyclical",
      "NVDA": "Technology",
      "SPY": "Market",
      "QQQ": "Technology",
      "IWM": "Small Cap",
      "DIA": "Large Cap"
    };
    
    // Define sector averages
    const sectorAverages = {
      "Technology": {
        pegRatio: 1.8,
        forwardPE: 24.0,
        priceToBook: 7.5,
        priceToSales: 5.0
      },
      "Consumer Cyclical": {
        pegRatio: 1.5,
        forwardPE: 20.0,
        priceToBook: 4.5,
        priceToSales: 2.5
      },
      "Market": {
        pegRatio: 1.5,
        forwardPE: 18.5,
        priceToBook: 3.2,
        priceToSales: 2.4
      },
      "Small Cap": {
        pegRatio: 1.3,
        forwardPE: 16.0,
        priceToBook: 2.0,
        priceToSales: 1.5
      },
      "Large Cap": {
        pegRatio: 1.6,
        forwardPE: 19.0,
        priceToBook: 3.5,
        priceToSales: 2.8
      },
      "Default": {
        pegRatio: 1.5,
        forwardPE: 18.0,
        priceToBook: 3.0,
        priceToSales: 2.0
      }
    };
    
    // Get the sector for the symbol
    const sector = sectorMappings[symbol] || "Default";
    
    // Return the sector averages
    return sectorAverages[sector];
  } catch (error) {
    Logger.log(`Error fetching sector averages for ${symbol}: ${error}`);
    
    // Return placeholder data
    return {
      pegRatio: 0,
      forwardPE: 0,
      priceToBook: 0,
      priceToSales: 0
    };
  }
}

/**
 * Formats the fundamental metrics data for display
 * @param {Array} fundamentalMetrics - Array of fundamental metrics data objects
 * @return {String} Formatted fundamental metrics data
 */
function formatFundamentalMetricsData(fundamentalMetrics) {
  try {
    let formattedData = "FUNDAMENTAL METRICS DATA:\n";
    
    // Check if we have data
    if (!fundamentalMetrics || fundamentalMetrics.length === 0) {
      return "No fundamental metrics data available.";
    }
    
    // Add count of stocks/ETFs
    formattedData += `- Metrics for ${fundamentalMetrics.length} stocks/ETFs:\n`;
    
    // Group stocks by category
    const indices = fundamentalMetrics.filter(stock => ["SPY", "QQQ", "IWM", "DIA"].includes(stock.symbol));
    const magSeven = fundamentalMetrics.filter(stock => ["AAPL", "MSFT", "GOOGL", "AMZN", "META", "TSLA", "NVDA"].includes(stock.symbol));
    const otherStocks = fundamentalMetrics.filter(stock => 
      !["SPY", "QQQ", "IWM", "DIA", "AAPL", "MSFT", "GOOGL", "AMZN", "META", "TSLA", "NVDA"].includes(stock.symbol)
    );
    
    // Format all stocks using the formatStockGroup function
    formattedData += formatStockGroup(fundamentalMetrics);
    
    // Add source and timestamp
    formattedData += `\nSource: Multiple financial data providers, as of ${new Date().toLocaleString()}\n`;
    
    return formattedData;
  } catch (error) {
    Logger.log(`Error formatting fundamental metrics data: ${error}`);
    return "Error formatting fundamental metrics data.";
  }
}

/**
 * Formats a group of stocks for display
 * @param {Array} stocks - Array of stock data objects
 * @return {String} Formatted stock data
 */
function formatStockGroup(stocks) {
  try {
    let formattedData = "";
    
    // Process each stock
    for (const stock of stocks) {
      // Get the symbol and name
      const symbol = stock.symbol || "Unknown";
      const name = stock.name || "Unknown";
      
      formattedData += `* ${symbol} (${name}):\n`;
      
      // Add price information if available
      if (stock.price !== null) {
        const priceFormatted = `$${stock.price.toFixed(2)}`;
        let priceChangeFormatted = "";
        
        if (stock.priceChange !== null && stock.percentChange !== null) {
          const changePrefix = stock.priceChange >= 0 ? '+' : '';
          const percentPrefix = stock.percentChange >= 0 ? '+' : '';
          priceChangeFormatted = ` (${changePrefix}${stock.priceChange.toFixed(2)}, ${percentPrefix}${stock.percentChange.toFixed(1)}%)`;
        }
        
        formattedData += `  - Price: ${priceFormatted}${priceChangeFormatted}\n`;
      } else if (stock.formattedPrice && stock.formattedPriceChange) {
        // Use pre-formatted price if available
        formattedData += `  - Price: ${stock.formattedPrice} ${stock.formattedPriceChange}\n`;
      }
      
      // Add volume and market cap if available
      if (stock.volume !== null) {
        formattedData += `  - Volume: ${stock.volume.toLocaleString()}\n`;
      }
      if (stock.marketCap !== null) {
        formattedData += `  - Market Cap: $${(stock.marketCap / 1e9).toFixed(1)}B\n`;
      }
      
      // Add fundamental metrics
      formattedData += `  - PEG Ratio: ${formatValue(stock.pegRatio)}\n`;
      formattedData += `  - Forward P/E: ${formatValue(stock.forwardPE)}\n`;
      formattedData += `  - Price to Book: ${formatValue(stock.priceToBook)}\n`;
      formattedData += `  - Price to Sales: ${formatValue(stock.priceToSales)}\n`;
      formattedData += `  - Debt to Equity: ${formatValue(stock.debtToEquity)}\n`;
      
      // Add ROE with percentage formatting if available
      if (stock.returnOnEquity !== null) {
        const roeValue = typeof stock.returnOnEquity === 'number' && stock.returnOnEquity <= 1 
          ? (stock.returnOnEquity * 100).toFixed(1) + '%' 
          : formatValue(stock.returnOnEquity);
        formattedData += `  - Return on Equity: ${roeValue}\n`;
      } else {
        formattedData += `  - Return on Equity: N/A\n`;
      }
      
      // Add Beta
      formattedData += `  - Beta: ${formatValue(stock.beta)}\n`;
      
      // Add a blank line between stocks
      formattedData += "\n";
    }
    
    return formattedData;
  } catch (error) {
    Logger.log(`Error formatting stock group: ${error}`);
    return "Error formatting stock data.";
  }
}

/**
 * Formats a value for display
 * @param {Number} value - The value to format
 * @return {String} Formatted value
 */
function formatValue(value) {
  if (value === null || value === undefined || isNaN(value)) {
    return "N/A";
  }
  
  return value.toFixed(2);
}

/**
 * Evaluates a metric compared to historical and sector averages
 * @param {Number} current - Current value
 * @param {Number} historical - Historical average
 * @param {Number} sector - Sector average
 * @param {String} metricType - Type of metric (PEG, P/E, etc.)
 * @param {Boolean} higherIsBetter - Whether higher values are better
 * @return {String} Evaluation
 */
function evaluateMetric(current, historical, sector, metricType, higherIsBetter = false) {
  if (current === null || historical === null || sector === null || 
      current === 0 || historical === 0 || sector === 0) {
    return "Insufficient data";
  }
  
  // Calculate percentage differences
  const histDiff = ((current - historical) / historical) * 100;
  const sectorDiff = ((current - sector) / sector) * 100;
  
  // Determine if the metric is favorable
  let histFavorable = higherIsBetter ? (histDiff > 0) : (histDiff < 0);
  let sectorFavorable = higherIsBetter ? (sectorDiff > 0) : (sectorDiff < 0);
  
  // Evaluation based on differences
  if (Math.abs(histDiff) < 10 && Math.abs(sectorDiff) < 10) {
    return "Fairly valued";
  } else if (histFavorable && sectorFavorable) {
    return "Favorable";
  } else if (!histFavorable && !sectorFavorable) {
    return "Unfavorable";
  } else {
    return "Mixed signals";
  }
}

/**
 * Generates analysis for a stock/ETF based on its metrics
 * @param {String} symbol - The stock/ETF symbol
 * @param {Object} metrics - Current fundamental metrics
 * @param {Object} historicalAverages - Historical average metrics (optional)
 * @param {Object} sectorAverages - Sector average metrics (optional)
 * @return {String} Analysis
 */
function generateAnalysis(symbol, metrics, historicalAverages = {}, sectorAverages = {}) {
  try {
    let analysis = `Analysis for ${symbol}: `;
    
    // Check if this is an ETF or stock
    const isETF = isETF(symbol);
    
    // Basic information
    if (metrics.company) {
      analysis += `${metrics.company}. `;
    }
    
    // Industry and sector information
    if (metrics.industry && metrics.sector) {
      analysis += `It operates in the ${metrics.sector} sector and ${metrics.industry} industry. `;
    }
    
    // Market cap information
    if (metrics.marketCap) {
      analysis += `With a market capitalization of ${metrics.formattedMarketCap}, it is a ${metrics.marketCap >= 100e9 ? 'large-cap' : metrics.marketCap >= 2e9 ? 'mid-cap' : 'small-cap'} company. `;
    }
    
    // Volume information
    if (metrics.volume) {
      analysis += `It has a daily trading volume of ${metrics.formattedVolume}. `;
    }
    
    // Price and change information
    if (metrics.price && metrics.priceChange) {
      analysis += `Currently trading at ${metrics.formattedPrice}${metrics.formattedPriceChange}. `;
    }
    
    if (isETF) {
      // ETF analysis
      analysis += `${symbol} is an ETF. `;
      
      if (metrics.expenseRatio) {
        analysis += `It has an expense ratio of ${metrics.expenseRatio * 100}%. `;
      }
    } else {
      // Stock analysis
      analysis += `${symbol} is a stock. `;
      
      // PEG Ratio analysis
      if (metrics.pegRatio) {
        if (metrics.pegRatio < 1.0) {
          analysis += `With a PEG ratio of ${formatValue(metrics.pegRatio)}, the stock appears to be potentially undervalued relative to its growth rate. `;
        } else if (metrics.pegRatio < 2.0) {
          analysis += `With a PEG ratio of ${formatValue(metrics.pegRatio)}, the stock appears to be fairly valued relative to its growth rate. `;
        } else {
          analysis += `With a PEG ratio of ${formatValue(metrics.pegRatio)}, the stock may be overvalued relative to its growth rate. `;
        }
      }
      
      // Forward P/E analysis
      if (metrics.forwardPE) {
        if (metrics.forwardPE < 15) {
          analysis += `Its forward P/E ratio of ${formatValue(metrics.forwardPE)} is relatively low, suggesting potential undervaluation. `;
        } else if (metrics.forwardPE < 25) {
          analysis += `Its forward P/E ratio of ${formatValue(metrics.forwardPE)} is moderate, suggesting fair valuation. `;
        } else {
          analysis += `Its forward P/E ratio of ${formatValue(metrics.forwardPE)} is relatively high, suggesting potential overvaluation. `;
        }
      }
      
      // Price/Book analysis
      if (metrics.priceToBook) {
        if (metrics.priceToBook < 1.0) {
          analysis += `With a price-to-book ratio of ${formatValue(metrics.priceToBook)}, the stock is trading below its book value. `;
        } else if (metrics.priceToBook < 3.0) {
          analysis += `With a price-to-book ratio of ${formatValue(metrics.priceToBook)}, the stock is trading at a reasonable multiple of its book value. `;
        } else {
          analysis += `With a price-to-book ratio of ${formatValue(metrics.priceToBook)}, the stock is trading at a premium to its book value. `;
        }
      }
      
      // Return on Equity analysis
      if (metrics.returnOnEquity) {
        if (metrics.returnOnEquity > 0.2) {
          analysis += `It demonstrates strong profitability with a return on equity of ${formatValue(metrics.returnOnEquity * 100)}%. `;
        } else if (metrics.returnOnEquity > 0.1) {
          analysis += `It demonstrates solid profitability with a return on equity of ${formatValue(metrics.returnOnEquity * 100)}%. `;
        } else if (metrics.returnOnEquity > 0) {
          analysis += `It demonstrates modest profitability with a return on equity of ${formatValue(metrics.returnOnEquity * 100)}%. `;
        } else {
          analysis += `It currently shows negative profitability with a return on equity of ${formatValue(metrics.returnOnEquity * 100)}%. `;
        }
      }
      
      // Debt/Equity analysis
      if (metrics.debtToEquity) {
        if (metrics.debtToEquity < 0.5) {
          analysis += `The company has a conservative financial structure with a debt-to-equity ratio of ${formatValue(metrics.debtToEquity)}. `;
        } else if (metrics.debtToEquity < 1.5) {
          analysis += `The company has a moderate financial structure with a debt-to-equity ratio of ${formatValue(metrics.debtToEquity)}. `;
        } else {
          analysis += `The company has a leveraged financial structure with a debt-to-equity ratio of ${formatValue(metrics.debtToEquity)}. `;
        }
      }
    }
    
    // Beta analysis (applicable to both stocks and ETFs)
    if (metrics.beta) {
      if (metrics.beta < 0.8) {
        analysis += `It has historically been less volatile than the market with a beta of ${formatValue(metrics.beta)}. `;
      } else if (metrics.beta < 1.2) {
        analysis += `It has historically moved in line with the market with a beta of ${formatValue(metrics.beta)}. `;
      } else {
        analysis += `It has historically been more volatile than the market with a beta of ${formatValue(metrics.beta)}. `;
      }
    }
    
    // Dividend analysis (applicable to both stocks and ETFs)
    if (metrics.dividendYield) {
      if (metrics.dividendYield > 0.03) {
        analysis += `It offers an attractive dividend yield of ${formatValue(metrics.dividendYield * 100)}%. `;
      } else if (metrics.dividendYield > 0.01) {
        analysis += `It offers a moderate dividend yield of ${formatValue(metrics.dividendYield * 100)}%. `;
      } else if (metrics.dividendYield > 0) {
        analysis += `It offers a modest dividend yield of ${formatValue(metrics.dividendYield * 100)}%. `;
      }
    }
    
    return analysis.trim();
  } catch (error) {
    Logger.log(`Error generating analysis for ${symbol}: ${error}`);
    return `Error generating analysis for ${symbol}`;
  }
}

/**
 * Tests the fundamental metrics data retrieval
 */
function testFundamentalMetrics() {
  try {
    // Test with a few symbols
    const testSymbols = ["AAPL", "MSFT", "SPY", "AMZN"];
    Logger.log(`Testing fundamental metrics for symbols: ${testSymbols.join(", ")}`);
    
    // Retrieve the fundamental metrics
    const fundamentalMetrics = retrieveFundamentalMetrics(testSymbols);
    
    // Check if we have metrics
    if (!fundamentalMetrics.success) {
      Logger.log(`Error retrieving fundamental metrics: ${fundamentalMetrics.error}`);
      return;
    }
    
    // Log the metrics
    Logger.log(`Successfully retrieved fundamental metrics for ${fundamentalMetrics.metrics.length} symbols`);
    
    // Log detailed metrics for each symbol
    Logger.log("DETAILED METRICS BY SYMBOL:");
    fundamentalMetrics.metrics.forEach(metric => {
      Logger.log(`\n${metric.symbol} (${metric.isETF ? 'ETF' : 'Stock'}):`);
      Logger.log(`  PEG Ratio: ${formatValue(metric.pegRatio)}`);
      Logger.log(`  Forward P/E: ${formatValue(metric.forwardPE)}`);
      Logger.log(`  Price to Book: ${formatValue(metric.priceToBook)}`);
      Logger.log(`  Price to Sales: ${formatValue(metric.priceToSales)}`);
      Logger.log(`  Debt to Equity: ${formatValue(metric.debtToEquity)}`);
      Logger.log(`  Return on Equity: ${formatValue(metric.returnOnEquity * 100)}%`);
      Logger.log(`  Return on Assets: ${formatValue(metric.returnOnAssets * 100)}%`);
      Logger.log(`  Profit Margin: ${formatValue(metric.profitMargin * 100)}%`);
      Logger.log(`  Dividend Yield: ${formatValue(metric.dividendYield * 100)}%`);
      Logger.log(`  Beta: ${formatValue(metric.beta)}`);
      if (metric.isETF) {
        Logger.log(`  Expense Ratio: ${formatValue(metric.expenseRatio * 100)}%`);
      }
      Logger.log(`  Source: ${metric.source || 'Not specified'}`);
    });
    
    // Test the formatting function
    const formattedData = formatFundamentalMetricsData(fundamentalMetrics.metrics);
    Logger.log("\nFORMATTED FUNDAMENTAL METRICS DATA:");
    Logger.log(formattedData.substring(0, 500) + "...");
    
    // Test the analysis function directly for one symbol
    if (fundamentalMetrics.metrics.length > 0) {
      Logger.log("\nSAMPLE ANALYSES:");
      fundamentalMetrics.metrics.forEach(stock => {
        const analysis = generateAnalysis(
          stock.symbol, 
          stock, 
          {}, 
          {}
        );
        
        Logger.log(`\n${stock.symbol} Analysis:`);
        Logger.log(analysis);
      });
    }
    
    // Test with invalid symbol - just test error handling without including in results
    Logger.log("\nTESTING INVALID SYMBOL ERROR HANDLING:");
    const invalidSymbol = "INVALID_SYMBOL_123";
    
    // Test Google Finance error handling
    try {
      const googleData = fetchGoogleFinanceData(invalidSymbol);
      Logger.log(`Unexpected success with Google Finance for ${invalidSymbol}`);
    } catch (e) {
      Logger.log(`Expected error from Google Finance for ${invalidSymbol}: ${e.message}`);
    }
    
    // Test Yahoo Finance error handling
    try {
      const yahooData = fetchYahooFinanceData(invalidSymbol);
      Logger.log(`Unexpected success with Yahoo Finance for ${invalidSymbol}`);
    } catch (error) {
      Logger.log(`Expected error from Yahoo Finance for ${invalidSymbol}: ${error.message}`);
    }
    
    return "Test completed. Check the logs for results.";
  } catch (error) {
    Logger.log(`Error testing fundamental metrics: ${error}`);
    return `Error testing fundamental metrics: ${error}`;
  }
}

/**
 * Tests the enhanced fundamental metrics data retrieval with multiple symbols
 * This function tests the cascading approach with a variety of stock and ETF symbols
 */
function testEnhancedFundamentalMetrics() {
  try {
    Logger.log("=== TESTING ENHANCED FUNDAMENTAL METRICS RETRIEVAL ===");
    
    // Test with a variety of symbols (stocks and ETFs)
    const testSymbols = [
      "AAPL",  // Large cap tech stock
      "MSFT",  // Another large cap tech stock
      "SPY",   // ETF
      "XOM",   // Energy sector
      "TSLA",  // High growth stock
      "BRK-B", // Conglomerate with special character in symbol
      "VTI"    // Another ETF
    ];
    
    const results = {};
    
    // Test each symbol
    for (const symbol of testSymbols) {
      Logger.log(`\n--- Testing ${symbol} ---`);
      
      try {
        const startTime = new Date().getTime();
        
        // Yahoo Finance API endpoint for fundamentals data
        const apiUrl = `https://apidojo-yahoo-finance-v1.p.rapidapi.com/stock/get-fundamentals?region=US&symbol=${symbol}&lang=en-US&modules=assetProfile%2CsummaryProfile%2CfundProfile`;
        
        const options = {
          method: "GET",
          headers: {
            "X-RapidAPI-Key": "YOUR_API_KEY",
            "X-RapidAPI-Host": "apidojo-yahoo-finance-v1.p.rapidapi.com"
          },
          muteHttpExceptions: true
        };
        
        // Make the API request
        Logger.log(`Making fundamentals API request for ${symbol}...`);
        const response = UrlFetchApp.fetch(apiUrl, options);
        const statusCode = response.getResponseCode();
        
        if (statusCode === 200) {
          const data = JSON.parse(response.getContentText());
          
          if (data && data.quoteSummary && data.quoteSummary.result && data.quoteSummary.result.length > 0) {
            const result = data.quoteSummary.result[0];
            const yahooApiData = {};
            
            // Extract metrics from the API response
            if (result.defaultKeyStatistics) {
              const stats = result.defaultKeyStatistics;
              yahooApiData.pegRatio = stats.pegRatio ? stats.pegRatio.raw : 0;
              yahooApiData.priceToBook = stats.priceToBook ? stats.priceToBook.raw : 0;
              yahooApiData.beta = stats.beta ? stats.beta.raw : 0;
              
              // Log available metrics for debugging
              Logger.log(`Available metrics in defaultKeyStatistics: ${Object.keys(stats).join(', ')}`);
            }
            
            if (result.financialData) {
              const financials = result.financialData;
              yahooApiData.returnOnEquity = financials.returnOnEquity ? financials.returnOnEquity.raw : 0;
              yahooApiData.returnOnAssets = financials.returnOnAssets ? financials.returnOnAssets.raw : 0;
              yahooApiData.profitMargin = financials.profitMargin ? financials.profitMargin.raw : 0;
              yahooApiData.debtToEquity = financials.debtToEquity ? financials.debtToEquity.raw : 0;
            }
            
            // Get additional quote data for more metrics
            const quoteUrl = `https://apidojo-yahoo-finance-v1.p.rapidapi.com/market/v2/get-quotes?region=US&symbols=${symbol}`;
            Logger.log(`Making quote API request for ${symbol}...`);
            const quoteResponse = UrlFetchApp.fetch(quoteUrl, options);
            
            if (quoteResponse.getResponseCode() === 200) {
              const quoteData = JSON.parse(quoteResponse.getContentText());
              
              if (quoteData && quoteData.quoteResponse && quoteData.quoteResponse.result && quoteData.quoteResponse.result.length > 0) {
                const quote = quoteData.quoteResponse.result[0];
                
                yahooApiData.forwardPE = quote.forwardPE || 0;
                yahooApiData.priceToSales = quote.priceToSales || 0;
                yahooApiData.dividendYield = quote.dividendYield ? quote.dividendYield / 100 : 0; // Convert to decimal
              }
            }
            
            const endTime = new Date().getTime();
            const executionTime = (endTime - startTime) / 1000; // in seconds
            
            // Log the results
            Logger.log(`Execution time: ${executionTime.toFixed(2)} seconds`);
            Logger.log(`Metrics retrieved: ${Object.keys(yahooApiData).join(', ')}`);
            
            // Log some key metrics
            Logger.log(`PEG Ratio: ${yahooApiData.pegRatio || 'N/A'}`);
            Logger.log(`Forward P/E: ${yahooApiData.forwardPE || 'N/A'}`);
            Logger.log(`Price to Book: ${yahooApiData.priceToBook || 'N/A'}`);
            Logger.log(`Beta: ${yahooApiData.beta || 'N/A'}`);
            
            // Store results
            results[symbol] = {
              success: true,
              executionTime: executionTime,
              metrics: yahooApiData
            };
          } else {
            Logger.log(`No results found in quoteSummary for ${symbol}`);
            results[symbol] = {
              success: false,
              error: "No results found in quoteSummary"
            };
          }
        } else {
          Logger.log(`API returned status code ${statusCode} for ${symbol}`);
          results[symbol] = {
            success: false,
            error: `API returned status code ${statusCode}`
          };
        }
      } catch (error) {
        Logger.log(`Error testing ${symbol}: ${error}`);
        results[symbol] = {
          success: false,
          error: error.toString()
        };
      }
    }
    
    // Log summary of results
    Logger.log("\n=== TEST SUMMARY ===");
    for (const symbol in results) {
      const result = results[symbol];
      if (result.success) {
        Logger.log(`${symbol}: Success - Data source: ${result.dataSource} (${result.executionTime.toFixed(2)}s)`);
      } else {
        Logger.log(`${symbol}: Failed - ${result.error}`);
      }
    }
    
    return results;
  } catch (error) {
    Logger.log(`Error in testEnhancedFundamentalMetrics: ${error}`);
    return { success: false, error: error.toString() };
  }
}

/**
 * Tests the full retrieveFundamentalMetrics function with caching
 * This function will:
 * 1. Clear the cache for test symbols
 * 2. Call retrieveFundamentalMetrics once (should be cache misses)
 * 3. Call retrieveFundamentalMetrics again (should be cache hits)
 * 4. Compare execution times and verify data consistency
 */
function testFullFundamentalMetricsCaching() {
  try {
    // Choose test symbols
    const testSymbols = ["SPY", "QQQ", "AAPL"];
    
    // Clear the cache for test symbols
    const scriptCache = CacheService.getScriptCache();
    for (const symbol of testSymbols) {
      const cacheKey = `FUNDAMENTAL_METRICS_${symbol}`;
      scriptCache.remove(cacheKey);
      Logger.log(`Cleared cache for ${symbol}`);
    }
    
    Logger.log(`\nFIRST CALL - SHOULD RETRIEVE FRESH DATA FOR ALL SYMBOLS:`);
    const startTime1 = new Date().getTime();
    const result1 = retrieveFundamentalMetrics(testSymbols);
    const executionTime1 = (new Date().getTime() - startTime1) / 1000;

    // Update the logging to handle empty results
    Logger.log(`Retrieved ${result1.metrics.length} valid metrics in ${executionTime1.toFixed(3)} seconds`);
    if (result1.metrics.length === 0) {
      Logger.log('No valid metrics data returned');
    } else {
      Logger.log(`First call execution time: ${executionTime1.toFixed(3)} seconds`);
      Logger.log(`Status: ${result1.status}`);
      Logger.log(`Cache hits: ${result1.cachePerformance ? result1.cachePerformance.hits : 'N/A'}`);
      Logger.log(`Cache misses: ${result1.cachePerformance ? result1.cachePerformance.misses : 'N/A'}`);
      Logger.log(`Cache hit rate: ${result1.cachePerformance ? result1.cachePerformance.hitRate : 'N/A'}`);
     // Format the data
    const formattedData1 = formatFundamentalMetricsData(result1.metrics);
    Logger.log("\nFORMATTED FUNDAMENTAL METRICS DATA:");
    Logger.log(formattedData1.substring(0, 500) + "...");
    }
    
    Logger.log(`\nSECOND CALL - SHOULD USE CACHED DATA FOR ALL SYMBOLS:`);
    const startTime2 = new Date().getTime();
    const result2 = retrieveFundamentalMetrics(testSymbols);
    const executionTime2 = (new Date().getTime() - startTime2) / 1000;
    
    Logger.log(`Second call execution time: ${executionTime2.toFixed(3)} seconds`);
    Logger.log(`Status: ${result2.status}`);
    Logger.log(`Cache hits: ${result2.cachePerformance ? result2.cachePerformance.hits : 'N/A'}`);
    Logger.log(`Cache misses: ${result2.cachePerformance ? result2.cachePerformance.misses : 'N/A'}`);
    Logger.log(`Cache hit rate: ${result2.cachePerformance ? result2.cachePerformance.hitRate : 'N/A'}`);
    
    // Format the data
    const formattedData2 = formatFundamentalMetricsData(result2.metrics);
    
    Logger.log(`\nCACHING PERFORMANCE:`);
    Logger.log(`First call (fresh data): ${executionTime1.toFixed(3)} seconds`);
    Logger.log(`Second call (cached data): ${executionTime2.toFixed(3)} seconds`);
    
    const improvementPercent = ((executionTime1 - executionTime2) / executionTime1) * 100;
    Logger.log(`Performance improvement: ${improvementPercent.toFixed(1)}%`);
    
    // Verify data consistency by comparing the actual metrics objects
    let dataConsistent = true;
    
    // Check if we have the same number of items
    if (result1.metrics.length !== result2.metrics.length) {
      dataConsistent = false;
      Logger.log(`Data inconsistency: Different number of items (${result1.metrics.length} vs ${result2.metrics.length})`);
    } else {
      // Compare each metrics object
      for (let i = 0; i < result1.metrics.length; i++) {
        const metrics1 = result1.metrics[i];
        const metrics2 = result2.metrics[i];
        
        // Compare important fields
        const keysToCompare = ['symbol', 'name', 'price', 'priceChange', 'percentChange', 
                               'pegRatio', 'forwardPE', 'priceToBook', 'priceToSales', 
                               'debtToEquity', 'returnOnEquity', 'beta'];
        
        for (const key of keysToCompare) {
          // Skip lastUpdated and other time-based fields
          if (key === 'lastUpdated') continue;
          
          // Compare values with a tolerance for floating point differences
          if (typeof metrics1[key] === 'number' && typeof metrics2[key] === 'number') {
            // Allow small floating point differences
            if (Math.abs(metrics1[key] - metrics2[key]) > 0.0001) {
              dataConsistent = false;
              Logger.log(`Data inconsistency found in ${metrics1.symbol}.${key}: ${metrics1[key]} vs ${metrics2[key]}`);
            }
          } else if (JSON.stringify(metrics1[key]) !== JSON.stringify(metrics2[key])) {
            dataConsistent = false;
            Logger.log(`Data inconsistency found in ${metrics1.symbol}.${key}: ${metrics1[key]} vs ${metrics2[key]}`);
          }
        }
      }
    }
    
    Logger.log(`\nDATA CONSISTENCY CHECK:`);
    Logger.log(`Metrics data from both calls is identical: ${dataConsistent ? "Yes" : "No"}`);
    
    return {
      status: "success",
      firstCallTime: executionTime1,
      secondCallTime: executionTime2,
      improvementPercent: improvementPercent,
      dataConsistent: dataConsistent,
      firstCallCachePerformance: result1.cachePerformance,
      secondCallCachePerformance: result2.cachePerformance
    };
  } catch (error) {
    Logger.log(`Error in testFullFundamentalMetricsCaching: ${error}`);
    return {
      status: "error",
      message: `Test failed: ${error}`
    };
  }
}

/**
 * Retrieves recently mentioned stocks/ETFs from CNBC
 * @return {Array} Recently mentioned stocks/ETFs
 */
function retrieveRecentlyMentionedStocks() {
  try {
    Logger.log("Retrieving recently mentioned stocks/ETFs...");
    
    // This would be implemented with actual web scraping in a production environment
    // For example, using UrlFetchApp to fetch the CNBC website and parse the data
    
    // For now, we'll return a placeholder array of popular stocks
    // In a production environment, this would be dynamically scraped
    const stocks = [
      "AAPL",
      "MSFT",
      "GOOGL",
      "AMZN",
      "NVDA",
      "META",
      "TSLA",
      "BRK-B",
      "JPM",
      "V"
    ];
    
    Logger.log(`Retrieved ${stocks.length} recently mentioned stocks/ETFs.`);
    return stocks;
  } catch (error) {
    Logger.log(`Error retrieving recently mentioned stocks/ETFs: ${error}`);
    return ["AAPL", "MSFT", "GOOGL", "AMZN", "NVDA"]; // Fallback to a few major stocks
  }
}

/**
 * Helper function to get a company name from a symbol
 * @param {String} symbol - Stock/ETF symbol
 * @return {String} Company name
 */
function getCompanyName(symbol) {
  try {
    // First try to get the name from Google Finance
    try {
      // Get the shared finance spreadsheet
      const spreadsheet = getSharedFinanceSpreadsheet();
      
      // Create or get a sheet for company names
      let sheet = spreadsheet.getSheetByName("CompanyNames");
      if (!sheet) {
        sheet = spreadsheet.insertSheet("CompanyNames");
      }
      
      // Set up formula to fetch company name
      sheet.getRange("A1").setValue(symbol);
      sheet.getRange("B1").setFormula(`=GOOGLEFINANCE(A1,"name")`);
      
      // Wait for formula to calculate
      Utilities.sleep(1000);
      
      // Get the company name
      const companyName = sheet.getRange("B1").getValue();
      
      // If we got a valid name, return it
      if (companyName && companyName !== "#N/A" && companyName !== "#ERROR!") {
        return companyName;
      }
    } catch (e) {
      Logger.log(`Error getting company name from Google Finance: ${e.message}`);
    }
    
    // If we couldn't get the name from Google Finance, try a hardcoded list
    const companyNames = {
      // Major indices
      "SPY": "SPDR S&P 500 ETF",
      "QQQ": "Invesco QQQ Trust (NASDAQ-100 Index)",
      "IWM": "iShares Russell 2000 ETF",
      "DIA": "SPDR Dow Jones Industrial Average ETF",
      
      // Magnificent Seven
      "AAPL": "Apple Inc.",
      "MSFT": "Microsoft Corporation",
      "GOOGL": "Alphabet Inc. (Google)",
      "GOOG": "Alphabet Inc. (Google)",
      "AMZN": "Amazon.com, Inc.",
      "META": "Meta Platforms, Inc. (Facebook)",
      "TSLA": "Tesla, Inc.",
      "NVDA": "NVIDIA Corporation",
      
      // Other popular stocks
      "NFLX": "Netflix, Inc.",
      "JPM": "JPMorgan Chase & Co.",
      "V": "Visa Inc.",
      "JNJ": "Johnson & Johnson",
      "WMT": "Walmart Inc.",
      "PG": "Procter & Gamble Company",
      "MA": "Mastercard Incorporated",
      "UNH": "UnitedHealth Group Incorporated",
      "HD": "The Home Depot, Inc.",
      "BAC": "Bank of America Corporation",
      "XOM": "Exxon Mobil Corporation",
      "PFE": "Pfizer Inc.",
      "CSCO": "Cisco Systems, Inc.",
      "VZ": "Verizon Communications Inc.",
      "INTC": "Intel Corporation",
      "ADBE": "Adobe Inc.",
      "CRM": "Salesforce, Inc.",
      "PYPL": "PayPal Holdings, Inc.",
      "CMCSA": "Comcast Corporation",
      "COST": "Costco Wholesale Corporation",
      "ABT": "Abbott Laboratories",
      "AVGO": "Broadcom Inc.",
      "PEP": "PepsiCo, Inc.",
      "TMO": "Thermo Fisher Scientific Inc.",
      "ACN": "Accenture plc",
      "NKE": "NIKE, Inc.",
      "ABBV": "AbbVie Inc.",
      "TXN": "Texas Instruments Incorporated",
      "MRK": "Merck & Co., Inc.",
      "DHR": "Danaher Corporation",
      
      // Popular ETFs
      "VOO": "Vanguard S&P 500 ETF",
      "VTI": "Vanguard Total Stock Market ETF",
      "VXUS": "Vanguard Total International Stock ETF",
      "BND": "Vanguard Total Bond Market ETF",
      "VEA": "Vanguard FTSE Developed Markets ETF",
      "VWO": "Vanguard FTSE Emerging Markets ETF",
      "AGG": "iShares Core U.S. Aggregate Bond ETF",
      "IJR": "iShares Core S&P Small-Cap ETF",
      "IJH": "iShares Core S&P Mid-Cap ETF",
      "GLD": "SPDR Gold Shares",
      "SLV": "iShares Silver Trust",
      "XLF": "Financial Select Sector SPDR Fund",
      "XLK": "Technology Select Sector SPDR Fund",
      "XLE": "Energy Select Sector SPDR Fund",
      "XLV": "Health Care Select Sector SPDR Fund",
      "XLY": "Consumer Discretionary Select Sector SPDR Fund",
      "XLP": "Consumer Staples Select Sector SPDR Fund",
      "XLI": "Industrial Select Sector SPDR Fund",
      "XLU": "Utilities Select Sector SPDR Fund",
      "XLB": "Materials Select Sector SPDR Fund",
      "XLRE": "Real Estate Select Sector SPDR Fund"
    };
    
    // If we have a hardcoded name, return it
    if (companyNames[symbol]) {
      return companyNames[symbol];
    }
    
    // If all else fails, just return the symbol
    return symbol;
  } catch (error) {
    Logger.log(`Error getting company name for ${symbol}: ${error}`);
    return symbol;
  }
}

/**
 * Helper function to generate a random metric value
 * @param {Number} min - Minimum value
 * @param {Number} max - Maximum value
 * @return {Number} Random metric value
 */
function getRandomMetric(min, max) {
  return Math.random() * (max - min) + min;
}

/**
 * Tests the Yahoo Finance API with a simple query
 * @param {string} apiKey - Optional Yahoo Finance API key (if not provided, will use the stored key)
 * @return {Object} Test result with success status and error message if applicable
 */
function testYahooFinanceAPI(apiKey) {
  try {
    Logger.log("=== TESTING YAHOO FINANCE API ===");
    
    // Get the API key if not provided
    if (!apiKey) {
      const scriptProperties = PropertiesService.getScriptProperties();
      apiKey = scriptProperties.getProperty('YAHOO_FINANCE_API_KEY');
      
      if (!apiKey) {
        const errorMsg = "Yahoo Finance API key not found in script properties.";
        Logger.log(errorMsg);
        return { success: false, message: errorMsg };
      }
    }
    
    Logger.log(`Using API key: ${apiKey.substring(0, 5)}...`);
    
    // Test multiple endpoints to ensure comprehensive API testing
    const endpoints = [
      {
        name: "Fundamentals",
        url: "https://apidojo-yahoo-finance-v1.p.rapidapi.com/stock/get-fundamentals?region=US&symbol=AAPL&lang=en-US&modules=assetProfile%2CsummaryProfile%2CfundProfile"
      },
      {
        name: "Quote",
        url: "https://apidojo-yahoo-finance-v1.p.rapidapi.com/market/v2/get-quotes?region=US&symbols=AAPL"
      }
    ];
    
    const results = [];
    
    // Test each endpoint
    for (const endpoint of endpoints) {
      Logger.log(`\nTesting endpoint: ${endpoint.name}`);
      
      const options = {
        method: "GET",
        headers: {
          "X-RapidAPI-Key": apiKey,
          "X-RapidAPI-Host": "apidojo-yahoo-finance-v1.p.rapidapi.com"
        },
        muteHttpExceptions: true
      };
      
      Logger.log(`Making API request to: ${endpoint.url}`);
      
      try {
        // Make the API request
        const response = UrlFetchApp.fetch(endpoint.url, options);
        const statusCode = response.getResponseCode();
        const responseText = response.getContentText();
        
        // Log the response for debugging
        Logger.log(`Response status code: ${statusCode}`);
        
        // Check if the request was successful
        if (statusCode === 200) {
          const data = JSON.parse(responseText);
          
          // Log the keys in the response for debugging
          Logger.log(`Response keys: ${Object.keys(data).join(', ')}`);
          
          // Check for specific data structure based on endpoint
          let isValidData = false;
          let dataStructure = "";
          
          if (endpoint.name === "Fundamentals" && data.quoteSummary && data.quoteSummary.result) {
            isValidData = true;
            dataStructure = "quoteSummary.result";
          } else if (endpoint.name === "Quote" && data.quoteResponse && data.quoteResponse.result) {
            isValidData = true;
            dataStructure = "quoteResponse.result";
          }
          
          if (isValidData) {
            Logger.log(`${endpoint.name} endpoint returned valid data with structure: ${dataStructure}`);
            results.push({ 
              endpoint: endpoint.name, 
              success: true, 
              message: "API request successful" 
            });
          } else {
            // Still consider it a success if we get valid JSON, just log what we received
            Logger.log(`${endpoint.name} endpoint returned data but missing expected structure. Found keys: ${Object.keys(data).join(', ')}`);
            results.push({ 
              endpoint: endpoint.name, 
              success: true, 
              message: "API returned data but not in the expected format",
              data: Object.keys(data)
            });
          }
        }
      } catch (requestError) {
        Logger.log(`${endpoint.name} request error: ${requestError}`);
        results.push({ 
          endpoint: endpoint.name, 
          success: false, 
          message: requestError.toString() 
        });
      }
    }
    
    // Determine overall success based on individual endpoint results
    const allSuccess = results.every(result => result.success);
    const anySuccess = results.some(result => result.success);
    
    // Generate summary
    Logger.log("\n=== YAHOO FINANCE API TEST SUMMARY ===");
    for (const result of results) {
      Logger.log(`${result.endpoint}: ${result.success ? "Success" : "Failed"} - ${result.message}`);
    }
    
    if (allSuccess) {
      return { 
        success: true, 
        message: "All Yahoo Finance API endpoints tested successfully", 
        results: results 
      };
    } else if (anySuccess) {
      return { 
        success: true, 
        message: "Some Yahoo Finance API endpoints tested successfully", 
        results: results 
      };
    } else {
      return { 
        success: false, 
        message: "All Yahoo Finance API endpoint tests failed", 
        results: results 
      };
    }
  } catch (error) {
    Logger.log(`Yahoo Finance API test error: ${error}`);
    return { success: false, message: error.toString() };
  }
}

/**
 * Tests the Yahoo Finance API integration specifically
 * This function forces the use of Yahoo Finance API by skipping Google Finance
 */
function testYahooFinanceAPIIntegration() {
  try {
    Logger.log("=== TESTING YAHOO FINANCE API INTEGRATION ===");
    
    // Test with a variety of symbols (stocks and ETFs)
    const testSymbols = [
      "AAPL",  // Large cap tech stock
      "MSFT",  // Another large cap tech stock
      "SPY",   // ETF
      "XOM",   // Energy sector
      "TSLA"   // High growth stock
    ];
    
    const results = {};
    
    // Get the Yahoo Finance API key
    const scriptProperties = PropertiesService.getScriptProperties();
    const apiKey = scriptProperties.getProperty('YAHOO_FINANCE_API_KEY');
    
    if (!apiKey) {
      Logger.log('Yahoo Finance API key not found. Please set the YAHOO_FINANCE_API_KEY property.');
      return { success: false, error: "API key not found" };
    }
    
    // Test each symbol
    for (const symbol of testSymbols) {
      Logger.log(`\n--- Testing ${symbol} ---`);
      
      try {
        const startTime = new Date().getTime();
        
        // Yahoo Finance API endpoint for fundamentals data
        const apiUrl = `https://apidojo-yahoo-finance-v1.p.rapidapi.com/stock/get-fundamentals?region=US&symbol=${symbol}&lang=en-US&modules=assetProfile%2CsummaryProfile%2CfundProfile`;
        
        const options = {
          method: "GET",
          headers: {
            "X-RapidAPI-Key": apiKey,
            "X-RapidAPI-Host": "apidojo-yahoo-finance-v1.p.rapidapi.com"
          },
          muteHttpExceptions: true
        };
        
        // Make the API request
        Logger.log(`Making fundamentals API request for ${symbol}...`);
        const response = UrlFetchApp.fetch(apiUrl, options);
        const statusCode = response.getResponseCode();
        
        if (statusCode === 200) {
          const data = JSON.parse(response.getContentText());
          
          if (data && data.quoteSummary && data.quoteSummary.result && data.quoteSummary.result.length > 0) {
            const result = data.quoteSummary.result[0];
            const yahooApiData = {};
            
            // Extract metrics from the API response
            if (result.defaultKeyStatistics) {
              const stats = result.defaultKeyStatistics;
              yahooApiData.pegRatio = stats.pegRatio ? stats.pegRatio.raw : 0;
              yahooApiData.priceToBook = stats.priceToBook ? stats.priceToBook.raw : 0;
              yahooApiData.beta = stats.beta ? stats.beta.raw : 0;
              
              // Log available metrics for debugging
              Logger.log(`Available metrics in defaultKeyStatistics: ${Object.keys(stats).join(', ')}`);
            }
            
            if (result.financialData) {
              const financials = result.financialData;
              yahooApiData.returnOnEquity = financials.returnOnEquity ? financials.returnOnEquity.raw : 0;
              yahooApiData.returnOnAssets = financials.returnOnAssets ? financials.returnOnAssets.raw : 0;
              yahooApiData.profitMargin = financials.profitMargins ? financials.profitMargins.raw : 0;
              yahooApiData.debtToEquity = financials.debtToEquity ? financials.debtToEquity.raw : 0;
            }
            
            // Get additional quote data for more metrics
            const quoteUrl = `https://apidojo-yahoo-finance-v1.p.rapidapi.com/market/v2/get-quotes?region=US&symbols=${symbol}`;
            Logger.log(`Making quote API request for ${symbol}...`);
            const quoteResponse = UrlFetchApp.fetch(quoteUrl, options);
            
            if (quoteResponse.getResponseCode() === 200) {
              const quoteData = JSON.parse(quoteResponse.getContentText());
              
              if (quoteData && quoteData.quoteResponse && quoteData.quoteResponse.result && quoteData.quoteResponse.result.length > 0) {
                const quote = quoteData.quoteResponse.result[0];
                
                yahooApiData.forwardPE = quote.forwardPE || 0;
                yahooApiData.priceToSales = quote.priceToSales || 0;
                yahooApiData.dividendYield = quote.dividendYield ? quote.dividendYield / 100 : 0; // Convert to decimal
              }
            }
            
            const endTime = new Date().getTime();
            const executionTime = (endTime - startTime) / 1000; // in seconds
            
            // Log the results
            Logger.log(`Execution time: ${executionTime.toFixed(2)} seconds`);
            Logger.log(`Metrics retrieved: ${Object.keys(yahooApiData).join(', ')}`);
            
            // Log some key metrics
            Logger.log(`PEG Ratio: ${yahooApiData.pegRatio || 'N/A'}`);
            Logger.log(`Forward P/E: ${yahooApiData.forwardPE || 'N/A'}`);
            Logger.log(`Price to Book: ${yahooApiData.priceToBook || 'N/A'}`);
            Logger.log(`Beta: ${yahooApiData.beta || 'N/A'}`);
            
            // Store results
            results[symbol] = {
              success: true,
              executionTime: executionTime,
              metrics: yahooApiData
            };
          } else {
            Logger.log(`No results found in quoteSummary for ${symbol}`);
            results[symbol] = {
              success: false,
              error: "No results found in quoteSummary"
            };
          }
        } else {
          Logger.log(`API returned status code ${statusCode} for ${symbol}`);
          results[symbol] = {
            success: false,
            error: `API returned status code ${statusCode}`
          };
        }
      } catch (error) {
        Logger.log(`Error testing ${symbol}: ${error}`);
        results[symbol] = {
          success: false,
          error: error.toString()
        };
      }
    }
    
    // Log summary of results
    Logger.log("\n=== TEST SUMMARY ===");
    for (const symbol in results) {
      const result = results[symbol];
      if (result.success) {
        Logger.log(`${symbol}: Success - Data source: ${result.dataSource} (${result.executionTime.toFixed(2)}s)`);
      } else {
        Logger.log(`${symbol}: Failed - ${result.error}`);
      }
    }
    
    return results;
  } catch (error) {
    Logger.log(`Error in testYahooFinanceAPIIntegration: ${error}`);
    return { success: false, error: error.toString() };
  }
}

/**
 * Fetches data from Tradier API for a specific symbol
 * @param {String} symbol - The stock/ETF symbol
 * @return {Object} Fundamental metrics data from Tradier
 */
function fetchTradierData(symbol) {
  try {
    Logger.log(`Fetching Tradier data for ${symbol}`);
    
    // Initialize metrics with null values
    const metrics = {
      pegRatio: null,
      forwardPE: null,
      priceToBook: null,
      priceToSales: null,
      debtToEquity: null,
      returnOnEquity: null,
      returnOnAssets: null,
      profitMargin: null,
      dividendYield: null,
      beta: null,
      expenseRatio: null,
      company: null,
      industry: null,
      sector: null,
      price: null,
      marketCap: null,
      volume: null
    };
    
    // Get the API key from script properties
    const scriptProperties = PropertiesService.getScriptProperties();
    const tradierApiKey = scriptProperties.getProperty('TRADIER_API_KEY');
    
    if (!tradierApiKey) {
      Logger.log('Tradier API key not found. Please set the TRADIER_API_KEY property.');
      return metrics;
    }
    
    // Set up the API request options
    const options = {
      'method': 'GET',
      'headers': {
        'Authorization': `Bearer ${tradierApiKey}`,
        'Accept': 'application/json'
      },
      'muteHttpExceptions': true
    };
    
    // Helper function to make API requests with retry logic
    function makeApiRequest(url, maxRetries = 3) {
      let retries = 0;
      let response;
      
      while (retries < maxRetries) {
        try {
          response = UrlFetchApp.fetch(url, options);
          
          // If successful, return the response
          if (response.getResponseCode() === 200) {
            return JSON.parse(response.getContentText());
          }
          
          // If rate limited, wait and retry
          if (response.getResponseCode() === 429) {
            Logger.log(`Rate limited. Retrying in ${Math.pow(2, retries)} seconds...`);
            Utilities.sleep(Math.pow(2, retries) * 1000); // Exponential backoff
            retries++;
            continue;
          }
          
          // If other error, log and return null
          Logger.log(`API error: ${response.getResponseCode()} - ${response.getContentText()}`);
          return null;
        } catch (error) {
          Logger.log(`API request error: ${error}. Retry ${retries + 1}/${maxRetries}`);
          retries++;
          
          if (retries < maxRetries) {
            Utilities.sleep(Math.pow(2, retries) * 1000); // Exponential backoff
          }
        }
      }
      
      return null;
    }
    
    // First, get the company profile using the beta endpoint
    Logger.log(`Fetching company profile for ${symbol} from Tradier API`);
    const profileUrl = `https://api.tradier.com/v1/markets/fundamentals/company?symbols=${symbol}`;
    const profileData = makeApiRequest(profileUrl);
    
    if (profileData && profileData.length > 0 && profileData[0].results) {
      const results = profileData[0].results;
      
      // Find the company data
      const companyData = results.find(result => result.type === "Company");
      
      if (companyData && companyData.tables) {
        // Extract company profile data
        if (companyData.tables.company_profile) {
          const profile = companyData.tables.company_profile;
          metrics.company = profile.company_name;
          metrics.industry = profile.industry;
          metrics.sector = profile.sector;
        }
        
        // Extract market cap and volume
        if (companyData.tables.market_cap) {
          metrics.marketCap = companyData.tables.market_cap[0].value;
        }
        
        if (companyData.tables.volume) {
          metrics.volume = companyData.tables.volume[0].value;
        }
      }
    }
    
    // Next, get the financial ratios using the beta endpoint
    Logger.log(`Fetching financial ratios for ${symbol} from Tradier API`);
    const ratiosUrl = `https://api.tradier.com/v1/markets/fundamentals/ratios?symbols=${symbol}`;
    const ratiosData = makeApiRequest(ratiosUrl);
    
    if (ratiosData && ratiosData.length > 0 && ratiosData[0].results) {
      const results = ratiosData[0].results;
      
      // Process company ratios
      const companyData = results.find(result => result.type === "Company");
      if (companyData && companyData.tables) {
        // Extract operation ratios if available
        if (companyData.tables.operation_ratios_restate && companyData.tables.operation_ratios_restate.length > 0) {
          const ratios = companyData.tables.operation_ratios_restate[0].period_1y;
          
          if (ratios) {
            // Extract return on equity
            if (ratios.r_o_e !== undefined) {
              metrics.returnOnEquity = parseFloat(ratios.r_o_e);
            }
            
            // Extract return on assets
            if (ratios.r_o_a !== undefined) {
              metrics.returnOnAssets = parseFloat(ratios.r_o_a);
            }
            
            // Extract profit margin
            if (ratios.net_margin !== undefined) {
              metrics.profitMargin = parseFloat(ratios.net_margin);
            }
            
            // Extract debt to equity (may need calculation)
            if (ratios.financial_leverage !== undefined) {
              metrics.debtToEquity = parseFloat(ratios.financial_leverage) - 1;
            }
          }
        }
      }
      
      // Process stock-specific ratios
      const stockData = results.find(result => result.type === "Stock");
      if (stockData && stockData.tables) {
        // Extract valuation ratios if available
        if (stockData.tables.valuation_ratios) {
          const valuation = stockData.tables.valuation_ratios;
          
          // Extract PEG ratio
          if (valuation.peg_ratio) {
            metrics.pegRatio = parseFloat(valuation.peg_ratio);
          }
          
          // Extract forward P/E
          if (valuation.forward_pe) {
            metrics.forwardPE = parseFloat(valuation.forward_pe);
          }
          
          // Extract price to book
          if (valuation.price_to_book) {
            metrics.priceToBook = parseFloat(valuation.price_to_book);
          }
          
          // Extract price to sales
          if (valuation.price_to_sales) {
            metrics.priceToSales = parseFloat(valuation.price_to_sales);
          }
        }
      }
    }
    
    // If we still don't have dividend yield, try the dividends endpoint
    if (metrics.dividendYield === null) {
      Logger.log(`Fetching dividend data for ${symbol} from Tradier API`);
      const dividendsUrl = `https://api.tradier.com/v1/markets/dividends?symbols=${symbol}`;
      const dividendsData = makeApiRequest(dividendsUrl);
      
      if (dividendsData && dividendsData.dividends && dividendsData.dividends.dividend) {
        const dividend = dividendsData.dividends.dividend;
        if (dividend.yield) {
          metrics.dividendYield = parseFloat(dividend.yield);
        }
      }
    }
    
    // For ETFs, try to get expense ratio
    if (isETF(symbol)) {
      try {
        // Tradier doesn't have a direct ETF expense ratio endpoint
        // This is a placeholder - we'll keep the expense ratio as null
        Logger.log(`${symbol} is an ETF, but Tradier doesn't provide expense ratio data`);
      } catch (etfError) {
        Logger.log(`Error checking ETF data for ${symbol}: ${etfError}`);
      }
    }
    
    // Validate metrics for realistic values
    Object.keys(metrics).forEach(key => {
      metrics[key] = validateMetric(metrics[key], key);
    });
    
    Logger.log(`Final Tradier metrics for ${symbol}: ${JSON.stringify(metrics)}`);
    
    return metrics;
  } catch (error) {
    Logger.log(`Error in fetchTradierData for ${symbol}: ${error}`);
    
    // Return null values for all metrics
    return {
      pegRatio: null,
      forwardPE: null,
      priceToBook: null,
      priceToSales: null,
      debtToEquity: null,
      returnOnEquity: null,
      returnOnAssets: null,
      profitMargin: null,
      dividendYield: null,
      beta: null,
      expenseRatio: null,
      company: null,
      industry: null,
      sector: null,
      price: null,
      marketCap: null,
      volume: null
    };
  }
}

/**
 * Validates a metric value for realistic ranges
 * @param {Number} value - The metric value
 * @param {String} key - The metric key
 * @return {Number} Validated metric value
 */
function validateMetric(value, key) {
  // Define realistic ranges for each metric
  const ranges = {
    pegRatio: [0, 5],
    forwardPE: [5, 50],
    priceToBook: [0, 20],  
    priceToSales: [0, 20], 
    debtToEquity: [0, 5],
    returnOnEquity: [0, 1],
    returnOnAssets: [0, 1],
    profitMargin: [0, 1],
    dividendYield: [0, 1],
    beta: [0, 5],
    expenseRatio: [0, 1]
  };
  
  // Check if the value is within the realistic range
  if (value < ranges[key][0] || value > ranges[key][1]) {
    Logger.log(`Invalid value for ${key}: ${value}. Setting to null.`);
    return null;
  }
  
  return value;
}

/**
 * Formats a group of stocks for display
 * @param {Array} stocks - Array of stock data objects
 * @return {String} Formatted stock data
 */
function formatStockGroup(stocks) {
  try {
    let formattedData = "";
    
    // Process each stock
    for (const stock of stocks) {
      // Get the symbol and name
      const symbol = stock.symbol || "Unknown";
      const name = stock.name || "Unknown";
      
      formattedData += `* ${symbol} (${name}):\n`;
      
      // Add price information if available
      if (stock.price !== null) {
        const priceFormatted = `$${stock.price.toFixed(2)}`;
        let priceChangeFormatted = "";
        
        if (stock.priceChange !== null && stock.percentChange !== null) {
          const changePrefix = stock.priceChange >= 0 ? '+' : '';
          const percentPrefix = stock.percentChange >= 0 ? '+' : '';
          priceChangeFormatted = ` (${changePrefix}${stock.priceChange.toFixed(2)}, ${percentPrefix}${stock.percentChange.toFixed(1)}%)`;
        }
        
        formattedData += `  - Price: ${priceFormatted}${priceChangeFormatted}\n`;
      } else if (stock.formattedPrice && stock.formattedPriceChange) {
        // Use pre-formatted price if available
        formattedData += `  - Price: ${stock.formattedPrice} ${stock.formattedPriceChange}\n`;
      }
      
      // Add volume and market cap if available
      if (stock.volume !== null) {
        formattedData += `  - Volume: ${stock.volume.toLocaleString()}\n`;
      }
      if (stock.marketCap !== null) {
        formattedData += `  - Market Cap: $${(stock.marketCap / 1e9).toFixed(1)}B\n`;
      }
      
      // Add fundamental metrics
      formattedData += `  - PEG Ratio: ${formatValue(stock.pegRatio)}\n`;
      formattedData += `  - Forward P/E: ${formatValue(stock.forwardPE)}\n`;
      formattedData += `  - Price/Book: ${formatValue(stock.priceToBook)}\n`;
      formattedData += `  - Price/Sales: ${formatValue(stock.priceToSales)}\n`;
      formattedData += `  - Debt/Equity: ${formatValue(stock.debtToEquity)}\n`;
      
      // Add ROE with percentage formatting if available
      if (stock.returnOnEquity !== null) {
        const roeValue = typeof stock.returnOnEquity === 'number' && stock.returnOnEquity <= 1 
          ? (stock.returnOnEquity * 100).toFixed(1) + '%' 
          : formatValue(stock.returnOnEquity);
        formattedData += `  - Return on Equity: ${roeValue}\n`;
      } else {
        formattedData += `  - Return on Equity: N/A\n`;
      }
      
      // Add Beta
      formattedData += `  - Beta: ${formatValue(stock.beta)}\n`;
      
      // Add a blank line between stocks
      formattedData += "\n";
    }
    
    return formattedData;
  } catch (error) {
    Logger.log(`Error formatting stock group: ${error}`);
    return "Error formatting stock data.";
  }
}

/**
 * Tests the caching implementation for fundamental metrics data
 * This function will:
 * 1. Clear the cache for a test symbol
 * 2. Call retrieveFundamentalMetrics once (should be cache misses)
 * 3. Call retrieveFundamentalMetrics again (should be cache hits)
 * 4. Compare execution times and verify data consistency
 */
function testFundamentalMetricsCaching() {
  try {
 const cache = CacheService.getScriptCache();
    const defaultSymbols = ["SPY", "QQQ", "IWM", "DIA", "AAPL", "MSFT", "GOOGL", "AMZN", "META", "TSLA", "NVDA", "XOM", "CVX", "ZM"];
    defaultSymbols.forEach(symbol => {
      const cacheKey = `FUNDAMENTAL_METRICS_${symbol}`;
      cache.remove(cacheKey);
      Logger.log(`Cleared cache for: ${cacheKey}`);
    });
    Logger.log('Cleared fundamental metrics cache');
  } catch (error) {
    Logger.log(`Error clearing fundamental metrics cache: ${error}`);
    throw error;
  }
}

/**
 * Gets the shared finance spreadsheet for company data
 * @return {GoogleAppsScript.Spreadsheet.Spreadsheet} The shared finance spreadsheet
 */
function getSharedFinanceSpreadsheet() {
  try {
    const spreadsheetId = PropertiesService.getScriptProperties().getProperty('FINANCE_SPREADSHEET_ID');
    if (!spreadsheetId) {
      throw new Error('Finance spreadsheet ID not configured');
    }
    return SpreadsheetApp.openById(spreadsheetId);
  } catch (error) {
    Logger.log(`Error getting shared finance spreadsheet: ${error}`);
    throw error;
  }
}

/**
 * Tests the fundamental metrics caching system
 * @return {Object} Test results
 */
function testFundamentalMetricsCaching() {
  try {
    // Choose a test symbol
    const testSymbol = "QQQ";
    
    // Clear the cache for the test symbol
    const scriptCache = CacheService.getScriptCache();
    const cacheKey = `FUNDAMENTAL_METRICS_${testSymbol}`;
    scriptCache.remove(cacheKey);
    Logger.log(`Cleared cache for: ${cacheKey}`);
    
    Logger.log(`\nFIRST CALL - SHOULD RETRIEVE FRESH DATA:`);
    const startTime1 = new Date().getTime();
    const result1 = fetchFundamentalMetricsData(testSymbol);
    const executionTime1 = (new Date().getTime() - startTime1) / 1000;
    
    Logger.log(`First call execution time: ${executionTime1.toFixed(3)} seconds`);
    Logger.log(`Data source: ${result1.dataSource || "N/A"}`);
    Logger.log(`From cache: ${result1.fromCache ? "Yes" : "No"}`);
    Logger.log(`Price: ${result1.price ? `$${result1.price.toFixed(2)}` : "N/A"} ${result1.priceChange ? `(${result1.priceChange >= 0 ? '+' : ''}${result1.priceChange.toFixed(2)}, ${result1.percentChange >= 0 ? '+' : ''}${result1.percentChange.toFixed(1)}%)` : ""}`);
    Logger.log(`PEG Ratio: ${result1.pegRatio || "N/A"}`);
    Logger.log(`Forward P/E: ${result1.forwardPE || "N/A"}`);
    Logger.log(`Beta: ${result1.beta || "N/A"}`);
    
    Logger.log(`\nSECOND CALL - SHOULD USE CACHED DATA:`);
    const startTime2 = new Date().getTime();
    const result2 = fetchFundamentalMetricsData(testSymbol);
    const executionTime2 = (new Date().getTime() - startTime2) / 1000;
    
    Logger.log(`Second call execution time: ${executionTime2.toFixed(3)} seconds`);
    Logger.log(`Data source: ${result2.dataSource || "N/A"}`);
    Logger.log(`From cache: ${result2.fromCache ? "Yes" : "No"}`);
    
    Logger.log(`\nCACHING PERFORMANCE:`);
    Logger.log(`First call (fresh data): ${executionTime1.toFixed(3)} seconds`);
    Logger.log(`Second call (cached data): ${executionTime2.toFixed(3)} seconds`);
    
    const improvementPercent = ((executionTime1 - executionTime2) / executionTime1) * 100;
    Logger.log(`Performance improvement: ${improvementPercent.toFixed(1)}%`);
    
    // Verify data consistency
    const keysToCompare = ['symbol', 'name', 'price', 'priceChange', 'percentChange', 'pegRatio', 'forwardPE', 'priceToBook', 'beta'];
    let dataConsistent = true;
    
    for (const key of keysToCompare) {
      if (JSON.stringify(result1[key]) !== JSON.stringify(result2[key])) {
        dataConsistent = false;
        Logger.log(`Data inconsistency found in ${key}: ${result1[key]} vs ${result2[key]}`);
      }
    }
    
    Logger.log(`\nDATA CONSISTENCY CHECK:`);
    Logger.log(`Data from both calls is identical: ${dataConsistent ? "Yes" : "No"}`);
    
    return {
      status: "success",
      firstCallTime: executionTime1,
      secondCallTime: executionTime2,
      improvementPercent: improvementPercent,
      dataConsistent: dataConsistent
    };
  } catch (error) {
    Logger.log(`Error in testFundamentalMetricsCaching: ${error}`);
    return {
      status: "error",
      message: `Test failed: ${error}`
    };
  }
}

/**
 * Checks if a symbol is an ETF
 * @param {String} symbol - The stock/ETF symbol
 * @return {Boolean} True if the symbol is an ETF, false otherwise
 */
function isETF(symbol) {
  const knownETFs = [
    'SPY', 'QQQ', 'IWM', 'DIA', 'TLT', 'GLD', 'SLV', 'USO', 'UNG', 'HYG',
    'VWO', 'VEA', 'EFA', 'EEM', 'XLF', 'XLK', 'XLE', 'XLU', 'XLRE', 'XLY',
    'XLP', 'XLI', 'XLB', 'XLC', 'XLY', 'XLP', 'XLI', 'XLB', 'XLC', 'XLY',
    'XLV', 'XLP', 'XLU', 'XLRE', 'XLY', 'XLK', 'XLF', 'XLE', 'XLU', 'XLRE',
    'XLY', 'XLK', 'XLF', 'XLE', 'XLU', 'XLRE', 'XLY', 'XLK', 'XLF', 'XLE',
    'XLU', 'XLRE', 'XLY', 'XLK', 'XLF', 'XLE', 'XLU', 'XLRE', 'XLY', 'XLK',
    'XLF', 'XLE', 'XLU', 'XLRE', 'XLY', 'XLK', 'XLF', 'XLE', 'XLU', 'XLRE',
    'XLY', 'XLK', 'XLF', 'XLE', 'XLU', 'XLRE', 'XLY', 'XLK', 'XLF', 'XLE',
    'XLU', 'XLRE', 'XLY', 'XLK', 'XLF', 'XLE', 'XLU', 'XLRE', 'XLY', 'XLK',
    'XLF', 'XLE', 'XLU', 'XLRE', 'XLY', 'XLK', 'XLF', 'XLE', 'XLU', 'XLRE'
  ];
  
  return knownETFs.includes(symbol.toUpperCase());
}